# BOJ 2615 오목

## 🌈 풀이 후기

- dfs를 이용해서 풀었습니다.
- 왼쪽 아래 대각선을 먼저 탐색하는 경우 가장 왼쪽에 있는 좌표를 출력하는 부분에 문제가 있기 때문에 가로를 먼저 탐색하지 않고 세로를 먼저 탐색하였습니다. ( i → j 가 아닌 j → i)
- 문제에도 주석을 달았지만 범위 초과하는 부분에서 잘 이해가 되지 않는 부분이 있습니다..

## 👩‍🏫 문제 풀이

**변수**

```tsx
final static int N = 19; // 19로 고정
static int[][] map = new int[21][21]; // 범위 초과 문제로 패딩을 1씩 걸어줌
static boolean[][][] visit = new boolean[21][21][4]; // 방향을 확인하는 d 추가
static int[] dr = { 0, 1, -1, 1 }; // 오른쪽 , 아래 , 오른쪽 위 대각선, 오른쪽 아래 대각선 4가지 경우.
static int[] dc = { 1, 0, 1, 1 };
```

1. 오목을 찾아야 하는데 순서대로 찾으면 위,왼쪽,왼쪽위 대각선,왼쪽밑 대각선을 체크할 필요가 없습니다. 따라서 오른쪽, 아래, 오른쪽 위 대각선, 오른쪽 밑 대각선 4가지 경우만 체크해주면 됩니다.
2. visit에 방향을 확인하는 배열을 따로 만들어서 해당 방향으로 5칸 연결되어 있는지 확인합니다.
3. 해당 방향으로 끝까지 가는 경우가 5일 경우에만 출력해 주기 때문에 6인 경우는 자연스럽게 빠집니다.

*범위를 체크 안해줬는데 map[nr][nc] 인덱스 에러가 안나는지 정확히 모르겠네요... 

## 핵심 코드

```java

	private static int dfs(int r, int c, int d, int check) {
		visit[r][c][d] = true;
		int nr = r + dr[d];
		int nc = c + dc[d];
		
		if (map[nr][nc] == check)
			return dfs(nr, nc, d, check)+1;

		return 1;
	}
```
