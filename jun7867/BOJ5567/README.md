# BOJ 5567: 결혼식

## 🌈 풀이 후기

- 친구의 친구까지만 구하면 돼서 for문을 두번 사용해 구했습니다.
- dfs로 풀면 더 효율적일것 같은데 친구의 친구를 구하는덴 얼마 안걸릴거 같아서 그냥 구했습니다.
- 근데 a가 b보다 항상 작은데 왜 map[a][b]만 체크하면 틀릴까요??? map[b][a]도 같이 연결시켜줘야 안틀리던데..... 제가 잘못 이해한건가요?? ㅠㅠ

## 👩‍🏫 문제 풀이

1. 연결 관계를 2차원 배열(map)에 저장합니다.
2. 1부터 연결된 친구들을 확인합니다.
- 만약 방문하지 않은 친구라면 방문체크를 해주고 count를 증가시켜 줍니다.
- 1과 연결된 친구와 친구들을 for문을 돌아주면서 연결되었고 방문처리 되지 않은 친구를 찾아줍니다. 

### 핵심 코드

```java
private static void sol(int idx, int start) {
	for (int i = 2; i <= N; i++) {
		if (map[1][i] == 1) {
			// 친구 체크
			if (!visit[i]) {
				visit[i] = true;
				cnt++;
			}
			
			// 친구의 친구 체크
			for (int j = 2; j <= N; j++) {
				if(!visit[j] && map[i][j]==1) {
					visit[j]=true;
					cnt++;
				}
			}
		}
	}
}
```
