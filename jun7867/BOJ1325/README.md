# BOJ 1325 효율적인 해킹

## 🌈 풀이 후기

- 알고리즘은 어렵지 않았으나 시간초과 때문에 고생했습니다...
- 처음에 Bfs로 접근하다가 시간초과를 해결할 수 없어서 dfs로 바꿔봤습니다.
- 시간을 최대한 줄이기 위해 BufferedWriter를 사용하였습니다.
- 처음에 문제를 잘못 이해해서 신뢰 관계를 동등 관계라고 인식하고 문제를 풀다가 시간을 낭비했습니다.. 문제를 제대로 읽는 습관을 기르겠습니다.

## 👩‍🏫 문제 풀이

1. List A 인덱스에 B를 저장시킨다. 

```java
for(int i=0;i<M;i++) {
			st = new StringTokenizer(br.readLine()," ");
			int a=Integer.parseInt(st.nextToken());
			int b=Integer.parseInt(st.nextToken());
			list[a].add(b);
}
```

2. 1부터 N과 같을 때까지 dfs를 돌려주는데 매 반복마다 visit를 초기화 시켜준다.

3. 신뢰 관계를 반대로 ( A → B 로 접근한다)  

예를 들어 

3 1

5 3 

의 관계가 있다면 

1과 연결된 3, 3과 연결된 5가 연결되어 있다.

각각의 연결 상태에 따라 따로 연결 횟수를 저장한다면 

3 1

3 2

4 3

5 3

연결 관계에서

최종적으로 연결 횟수는 1부터 5까지 [3, 3, 2, 0, 0] 가 된다.

4. 접근가능한 count중 max와 같은 것들을 찾아서 오름차순으로 출력한다.
