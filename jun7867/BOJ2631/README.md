# BOJ 2631: 줄세우기

## 🌈 풀이 후기

- 처음에는 Greedy 적으로 생각 하려다가 옮기는 횟수가 제일 적은것은 결국 제일 긴 것을 남기고 나머지만 옮기면 된다는 것을 알게 되었습니다.

- 즉, LIS 문제인데 LIS는 DP로 구현할 수 있어서 DP를 사용하였습니다. 다만 이 방법보다 시간 복잡도가 O(nlogn)인 이진탐색 방법이 있는데 기억이 잘 안나서 DP인 O(N^2)을 사용하였습니다..

- 시간이 되면 이진탐색 방법도 공부해 보려고 합니다.

## 👩‍🏫 문제 풀이

**알고리즘 - DP (LIS)**

(Dp[i] = max(D[i],D[j]+1) if arr[j] < arr[i])

DP를 사용해서 자기보다 먼저 나온 수 중에 작은 수가 있으면 그 수에 +1를 해주면서 가장 긴 증가하는 수열을 구해주면 됩니다.

최종적으로 전체 길이중에 LIS를 뺀 값들이 옮기면 되는 수입니다.

(LIS중 가장 긴 값을 찾아야 되기 때문에 max를 통해서 따로 구해줬습니다.)


**핵심 코드**

```tsx
for (int i = 1; i < N; i++) {
	for (int j = 0; j < i; j++) {
		if (numbers[j] < numbers[i])
			dp[i] = Math.max(dp[i], dp[j] + 1);
	}
	max = max < dp[i] ? dp[i] : max;
}
```
