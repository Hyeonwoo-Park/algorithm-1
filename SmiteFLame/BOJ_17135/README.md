# BOJ 17135번 캐슬 디펜스

## 🌈 풀이 후기
조합과 시뮬레이션을 합쳐서 문제를 풀었습니다.<br>
중복되는 점이 많아서 최대한 함수를 분리하여서 문제를 풀었습니다.<br>
함수를 분리해도 4중 for문 + 3중 if문이 있어서 함수로 제대로 분리하지 못했습니다<br>
화살의 거리를 확인하고 왼쪽부터 검사하는 과정에서 많은 시간을소요했습니다.

## 👩‍🏫 문제 풀이
<br>

### 변수
- N(int), M(int): 행과 열의 개수
- D(int): 공격 거리 제한
- map(int[][]): 적의 위치
- isSelected(boolean[]): 조합을 위한 배열
- enemy(Set\<Pair\>) - 한 번에 죽인 적들을 저장할 set

- pair - 적의 위치(X, Y)와 언제 죽었는지를 표현할 (level)을 가지고 있는다.

### 원리
1. 모든 조합의 경우의 수를 제작
2. 조합을 만들 때 마다 적을 죽일 수 있는 최대의 수를 구한다.
3. 거리가 1부터 D까지의 적을 순서대로 발견한다.<br>
3-1. 다이아몬드 스탭처럼 왼쪽부터 우선적으로 검사한다. - 별도
4. 적을 발견하면 Set에 넣어서 중복처리를 진행한다.<br>
4-1. 레벨이 같으면 같은 턴에 죽인 것이므로 true를 보내어 적 탐색을 종료한다<br>
4-2. 레벨이 다르면 다른 턴에 죽인 것이므로 false를 통해서 탐색을 이어 나간다.<br>
5. 모든 행 만큼 적을 공격 한 후 Set의 크기를 확인하고 2번부터 4번까지 반복을 반복한다.





```java
L:
for (int i = 0; i < D; i++) {
    for (int j = -i; j <= i; j++) {
        int x = level - (i - Math.abs(j));
        if (canMove(x, ar + j)) {
            if (map[x][ar + j] == 1) {
                if(input(x, ar + j, level)) {
                    break L;
                }
            }
        }
    }
}
```
- 왼쪽부터 데이터를 검사하는 코드<br>
1. 0부터 D까지 순서대로 검사한다.
2. 자신의 위치에서 좌에서 우로 순서대로 검사한다
3. 남는 거리만큼 앞으로 나가서 검사한다.

```
D가 3일 때 순서 (A가 방향)
X X X X
X 6 X X
5 3 7 X
2 1 4 8
- A - -
```