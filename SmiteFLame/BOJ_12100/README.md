# BOJ 12100번 2048(easy)

## 🌈 풀이 후기
공부하기 싫어서 심심할때 했었던 게임이네요 예전에 16384까지 만들었습니닿ㅎ<br>
위, 아래, 왼쪽, 오른쪽 을 다 구분하여 따로 제작하여 시뮬레이션과 DFS를 합쳐서 풀었습니다<Br>

## 👩‍🏫 문제 풀이
<br>

### 변수
- N(int): 가로세로 크기
- map(int[][]): DFS에서 사용하는 map
- newMap(int[][]): 새로 복사되는 map

### 원리
1. 데이터를 처음 입력 받습니다.
2. 처음에 상, 하, 좌, 우를 골라서 DFS를 시작합니다.
3. 입력받은 행동을 실행합니다.
4. 입력된 행동이 완료 되었으면 다시 상, 하, 좌, 우를 골라서 DFS를 시작합니다.
5. 5번이 실행되었다면 최대값을 갱신합니다.


```java

if (loc == 0) {
        // 아래에 있는 데이터를 찾아서 합치는 코드

        // 모든 행을 체크한다.
        for (int j = 0; j < N; j++) {

                // 맨 위의 열부터 확인
	        for (int k = N - 1; k >= 0; k--) {

                        // 만약 처음 블록을 확인할 때 까지
		        for (int i = k - 1; i >= 0; i--) {

                                // 만약 아래에 있는 블록이 서로 같다면 합친다
			        if (map[k][j] == map[i][j]) {

                                        // 아래에 블록을 합치고 위는 삭제
				        map[i][j] *= 2;
				        map[k][j] = 0;

                                        // 다다음 블록으로 넘어간다
				        k = i;
				        break;
                                        
                                // 만약 블록이 0이 아니라면 이번 것은 넘어간다.
			        } else if (map[i][j] != 0) {
				        break;
			        }
		        }
	        }
        }

        // 블록을 다시 내려주는 과정

        // 모든 행에 대하여 확인
        for (int j = 0; j < N; j++) {

                // 맨 위에서 부터 확인
        	for (int i = N - 1; i >= 0; i--) {
                        // 0이 아니라면 pass
        		if (map[i][j] != 0)
        			continue;
        		for (int k = i - 1; k >= 0; k--) {
        			if (map[k][j] == 0)
        				continue;
        			map[i][j] = map[k][j];
        			map[k][j] = 0;
        			break;
        		}
        	}
        }
}

.
.
.
.

// 데이터를 복사하여 추가
for (int i = 0; i < 4; i++) {
	DFS(copyMap(map), i, cnt + 1);
}
```