# BOJ 1563번 개근상

## 🌈 풀이 후기
처음에는 간단한 부분집합인 줄 알고 풀었습니다.<br>
1000값을 넣어봤는데 시간이 너무 오래 걸리더군요(30번 값도 십 몇초 결렸습니다.)<br>
재귀함수가 너무 많이 호출되는 거 같아서 DP방법으로 풀었습니다.<br>
<br>
BufferedReader를 쓰려고 하는데 데이터가 하나밖에 없어서 Scanner를 사용했습니다.

## 👩‍🏫 문제 풀이
<br>

### 변수
- N(int): 데이터의 수
- DP(int[][][]) : DP 데이터 저장값([N번쨰][결석의 수][지각의 수])

### 원리
1. 아무일도 일어나지 않는 값을 기본으로 1로 초기화합니다.
2. 지각 여부 상관 없이 결석을 카운트 합니다.<br>
2-1. 결석 0번 값은 다시 초기화가 가능하므로 전번 결석 0,1,2 회 값의 합 가져옵니다.<br>
2-2. 결석 1,2번 값은 연속적이므로 전번 0,1번 값들을 가져옵니다.
3. 지각을 하게 되면 결석이 초기화가 되므로 결석 0번 값만 추가합니다. <br>
3-1. 전번 결석 0,1,2번이면서 지각이 없는 값을 결석0번, 지각1번에 추가합니다.

### 핵심코드
- 부분 집합으로 만들었던 코드
``` java
private static void subset(int cnt, int late, int absent) {
	if (cnt == N) {
		ans++;
		return;
	}

//	1. 출석 한 경우
	subset(cnt + 1, late, 0);
		
//	2. 지각 한 경우
	if (late != 1) {
			subset(cnt + 1, late + 1, 0);
		}
//	3. 결석 한 경우
	if (absent != 2) {
		subset(cnt + 1, late, absent + 1);
	}
}
```

```java
DP[0][0][0] = 1;
for (int i = 1; i <= N; i++) {
	for (int j = 0; j < 2; j++) {
//		1. 결석 없는 경우
		DP[i][0][j] = (DP[i - 1][0][j] + DP[i - 1][1][j] + DP[i - 1][2][j]) % 1000000;
//		2. 결식 1번 있는 경우
		DP[i][1][j] = DP[i - 1][0][j];
//		3. 결식 2번 있는 경우
		DP[i][2][j] = DP[i - 1][1][j];
	}
//	지각 발생하는 경우
	DP[i][0][1] += (DP[i - 1][0][0] + DP[i - 1][1][0] + DP[i - 1][2][0]) % 1000000;

}

```