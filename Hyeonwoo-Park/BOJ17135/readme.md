# BOJ 17135번 [캐슬 디펜스](https://www.acmicpc.net/problem/17135)

## 🌈 풀이 후기
- 코드가 자꾸 지저분해져서 많이 힘들었습니다.
- 조합을 for문 3중첩이 아니라 next() 함수를 호출하면 다음 조합을 생성하는 방식으로 만드려고 했는데 실패했습니다.
- 한 공격 사이클에 죽는 적의 수를 세는 방법을 우아하게 구현하지 못했습니다.
## 👩‍🏫 문제 풀이
### 함수, 변수 설명
1. `board[][]`, `visit[][]` : 게임 판과 현재 게임에서 죽은 적을 저장하는 배열입니다.
1. `int attack(int[] archers, int line)`
    - 한턴에 모든 궁수가 공격하는 함수입니다.
    - 모든 필드를 조회하며, 이전에 죽지 않은(`visit[i][j] == 0`)적을 찾아 저장합니다.
    - 저장된 `nearest[]` 배열을 조회하며, 중복을 처리하고, 죽은 적의 수를 세며, 죽은 적을 제외(`visit[i][j] = 1`)합니다.
    - `int[] archers`: 궁수 위치의 조합 배열입니다.
    - `int line` : 적이 내려가는 방식을 거꾸로 생각하여, 궁수가 매턴 한줄씩 올라가는 느낌으로 설계하였습니다.
    - `nearest[3][3]` : 순서대로, 각 궁수별 가장 가까운 적의 거리, r, c 값이 저장됩니다. 최초 값은 {D(사정거리) + 1, 0, 0} 입니다.

### 풀이 방법
1. 3명의 궁수의 조합을 3중 포문으로 생성합니다.
2. N번의 턴 만큼 for문을 돌며,
    2-1. 모든 맵을 조회하여 각 궁수별 가장 가까운 적을 사살하고, 그 수를 카운팅합니다.
    2-2. 맨 마지막 한 줄을 제외합니다.
3. 최대값을 갱신합니다.