# BOJ 2615번 [오목](https://www.acmicpc.net/problem/2615)



## 🌈 풀이 후기

dfs인데 조금 특이한 dfs인것 같은 문제였다. 그래도 수업시간에 맨날 순열, 조합 같은 문제 풀다가 구현문제 푸니까 재밌었다!

## 👩‍🏫 문제 풀이

1. 2차원 배열 board를 탐색하면서 바둑알이 놓인 위치를 찾는데 탐색 순서를 1행->2행->...->N행 순서로 했다. (가장 왼쪽이 답이 되므로)
2. 바둑알을 만나면 흰색인지 검정색인지를 <code>who</code>라는 변수에 저장했다.
3. 해당 칸으로부터 4가지 방향(우상, 우, 우하, 하)을 탐색한다.
4. 탐색 결과, who값을 가진 칸을 만나면 <code>check()</code> 함수를 호출한다.
   - <code>boolean check(int x, int y, int[] dir, int who)</code> 
     : dir 값으로는 4가지 방향 중 앞으로 향할 한가지 방향을 담는다.
5. check() 안에서 while문을 수행하며 같은 색의 바둑알이면 cnt++ 해주고 다른 색의 바둑알이면 check()함수로 넘어온 좌표의 이전이전값을 확인한 후 리턴한다.
   (처음에는 return cnt==5로 결과값을 리턴했지만 이렇게 했을 경우 현재 바둑알 바로 이전 바둑알을 체크하지 못해 6개 이상이 될 수 있다.. 또한 나는 바둑알을 만나면 바로 check()함수를 호출하는 것이 아니라 주변 바둑알을 검사해서 같은 색이라면 주변 바둑알을 넘겼기 때문에 두번 이전 값을 검사해야했다. 이것때문에 고생함)